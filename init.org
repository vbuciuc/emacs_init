#+Title: My org init file. [WIP]

* Loading this file

Add to emacs init file:

#+BEGIN_SRC emacs-lisp
(org-babel-load-file "~/emacs_init/init.org")
#+END_SRC

* Setup
:PROPERTIES:
:header-args: :tangle yes
:END:

** Use spaces by default

#+BEGIN_SRC emacs-lisp
  (setq-default indent-tabs-mode nil)
#+END_SRC

** Package management

*** Set up packages

Repositories for packages.

#+NAME: package_repos
#+BEGIN_SRC emacs-lisp
(require 'package)
(setq
 package-archives '(("gnu" . "https://elpa.gnu.org/packages/")
                    ("org" . "https://orgmode.org/elpa/")
                    ("melpa" . "https://melpa.org/packages/")
                    ("melpa-stable" . "https://stable.melpa.org/packages/"))
 package-archive-priorities '(("melpa-stable" . 10) ("melpa" . 1)))
(package-initialize)
#+END_SRC

*** Use package

Use package is used to install all the other packages.

#+NAME: use_package
#+BEGIN_SRC emacs-lisp
(when (not package-archive-contents)
  (package-refresh-contents)
  (package-install 'use-package))

(require 'use-package)
#+END_SRC

** Font lock mode

Enables font lock mode (syntax highlighting in all buffers).

#+NAME: font_lock_mode
#+BEGIN_SRC emacs-lisp
(global-font-lock-mode 1)
#+END_SRC

** Default browser

o#+name: default_browser
#+begin_src emacs-lisp
(setq browse-url-browser-function `browse-url-chrome)
#+end_src

** Save backups in tmp dir

#+name backup_in_tmp
#+begin_src emacs-lisp :tangle yes
(setq backup-directory-alist
      `((".*" . ,temporary-file-directory)))
(setq auto-save-file-name-transforms
      `((".*" ,temporary-file-directory t)))
#+end_src

** Theme

#+begin_src emacs-lisp :tangle yes
  (load-theme 'tango-dark)
#+end_src

** Disable toolbar and menu

#+BEGIN_SRC emacs-lisp :tangle yes
  (menu-bar-mode -1)
  (tool-bar-mode -1)
#+END_SRC

** Start emacs server

#+BEGIN_SRC emacs-lisp
(server-start)
#+END_SRC

* Stable
:PROPERTIES:
:header-args: :tangle yes
:END:

Stable stuff shouldn't change too often.

** Company mode

Company mode is a completion framework.

*** Install company mode

#+name: install company mode
#+begin_src emacs-lisp :tangle yes
(use-package company
;; don't show compay-mode in modeline
  :diminish company-mode
  :init
  (setq
   company-dabbrev-ignore-case nil
   company-dabbrev-code-ignore-case nil
   company-dabbrev-downcase nil
   company-minimum-prefix-length 2)
  :config
  (global-company-mode t)
  (setq company-idle-delay 0)
  (global-set-key (kbd "s-SPC") 'company-complete))
#+end_src

*** Fuzzy matching in company mode: company-flx

#+name: company-flx
#+begin_src emacs-lisp :tangle yes
(use-package company-flx
  :ensure t
  :config
  (add-hook `global-company-mode-hook 'company-flx-mode)
  )
#+end_src

*** Documentation on completion candidates: company-quickhelp

#+name: company-quickhelp
#+begin_src emacs-lisp :tangle yes
(use-package company-quickhelp
  :ensure t
  :config
  (add-hook 'company-mode-hook (lambda () (company-quickhelp-mode 1))))
#+end_src

** Ido

Ido is a completion framework for minibuffer (ex: finding files, switching buffer)

*** Install flx-ido

Flx ido brings fuzzy matching to ido.

#+name: ido
#+begin_src emacs-lisp :tangle yes
(use-package flx-ido
  :ensure t
  :demand
  :init
  (setq
   ido-enable-flex-matching t
   ;; C-d to open directories
   ;; C-f to revert to find-file
   ido-show-dot-for-dired t
   ido-enable-dot-prefix t)
  :config
  (ido-mode 1)
  (ido-everywhere 1)
  (flx-ido-mode 1)
  :custom
  (flx-ido-threshold 20000 "Increase ido threshold")
  )
#+end_src

*** Ido vertical

Display ido results vertically

#+name: ido-vertical
#+begin_src emacs-lisp :tangle yes
(use-package ido-vertical-mode
  :ensure t
  :config
  (ido-vertical-mode 1))
#+end_src

*** Ido occur

Occur in minibuffer

#+name: ido-occur
#+begin_src emacs-lisp :tangle yes
(use-package ido-occur
  :ensure t
  :bind ("s-o" . ido-occur))
#+end_src

*** Ido completing read plus

#+name: ido-completing-read+
#+begin_src emacs-lisp :tangle yes
(use-package ido-completing-read+
  :ensure t
  :config
  (ido-ubiquitous-mode))
#+end_src

** Smex

#+name: smex
#+begin_src emacs-lisp :tangle yes
(use-package smex
  :ensure t
  :bind
  ("M-x" . 'smex)
  ("M-X" . 'smex-major-mode-commands)
  ("C-c C-c M-x" . 'execute-extended-command))
#+end_src

** Exec Path from Shell

Ensures that some env vars are copied from the parent shell.

#+NAME: exec_path
#+BEGIN_SRC emacs-lisp
(use-package exec-path-from-shell
 :ensure t
 :config
  (setq exec-path-from-shell-variables (quote ("PATH" "MANPATH" "GOPATH" "KUBECONFIG")))
  (exec-path-from-shell-initialize))
#+END_SRC

** Git
*** Git link

Git link generates links to git origin.

#+begin_src emacs-lisp :tangle yes
  (use-package git-link
    :ensure t
    :custom
    (git-link-remote-alist
     (quote
      (("github" git-link-github)
       ("bitbucket" git-link-bitbucket)
       ("gitorious" git-link-gitorious)
       ("gitlab" git-link-gitlab)
       ("git.ecd.axway.int" git-link-gitlab)))))
#+end_src

*** Global git gutter

#+begin_src emacs-lisp :tangle no
  (use-package git-gutter
    :ensure t
    :config
    (global-git-gutter-mode 1))
#+end_src

*** Magit

Magit is ___THE___ git interface

#+BEGIN_SRC emacs-lisp
(use-package magit
  :ensure t
  :config
  (global-set-key (kbd "C-x g") 'magit-status)
  (global-set-key (kbd "M-&") 'with-editor-async-shell-command))
#+END_SRC

** Projectile

#+NAME: projectile
#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :ensure t
    :init   (setq projectile-use-git-grep t)
    :config
    (projectile-mode t)
    (setq projectile-enable-caching t)
    (setq projectile-switch-project-action 'projectile-dired)
    (define-key projectile-mode-map (kbd "C-c p") 'projectile-command-map)
    :bind   (("s-f" . projectile-find-file)
	     ("s-F" . projectile-grep))
    :custom
    (projectile-project-root-files-bottom-up
     (quote
      ("pom.xml" ".git" ".hg" ".fslckout" "_FOSSIL_" ".bzr" "_darcs" ".projectile"))))
#+END_SRC

*** Projectile makes tramp slow

#+BEGIN_SRC emacs-lisp
(defadvice projectile-project-name (before projectile-project-name-on-tramp activate)
  (if (tramp-tramp-file-p default-directory)
      (setq-local projectile-project-name "TrampRemote")
    )
  )
#+END_SRC

*** Projectile ibuffer support

#+name: ibuffer-projectile
#+begin_src emacs-lisp :tangle yes
(use-package ibuffer-projectile
  :ensure t)
#+end_src

** Yasnippet

Snippets organized per mode.

#+BEGIN_SRC emacs-lisp
(use-package yasnippet
  :diminish yas-minor-mode
  :commands yas-minor-mode
  :config
  (yas-global-mode 1)
  (yas-reload-all)
  )
#+END_SRC

** Async

#+BEGIN_SRC emacs-lisp
(use-package async
  :ensure t
  :config
  (add-hook 'dired-mode-hook (lambda () (dired-async-mode 1))))
#+END_SRC

** Flycheck

#+BEGIN_SRC
(use-package flycheck
  :ensure t)
#+END_SRC

** Http

#+begin_src emacs-lisp :tangle yes
(use-package http
  :ensure t)
(use-package ob-http
  :ensure t)
#+end_src

** JQ

#+name: jq-mode
#+begin_src emacs-lisp :tangle yes
(use-package jq-mode
  :init
  (require 'ob-jq)
  :ensure t)
#+end_src

** Kubernetes

#+begin_src emacs-lisp :tangle yes
  (use-package kubernetes
    :ensure t
    :commands (kubernetes-overview)
    :custom
    (kubernetes-poll-frequency 3600)
    (kubernetes-redraw-frequency 3600)
    )

  (use-package kubernetes-tramp
    :ensure t)
#+end_src
** Yaml

Lint yaml with flycheck

#+name: flycheck-yamllint
#+begin_src emacs-lisp :tangle yes
(use-package flycheck-yamllint
  :ensure t
  :defer t
  :init
  (progn
    (eval-after-load 'flycheck
      '(add-hook 'flycheck-mode-hook 'flycheck-yamllint-setup))))
#+end_src

** Shell mode

#+name: bash-comppletion
#+begin_src emacs-lisp 
  (use-package bash-completion
    :ensure t
    :config
    (defun my-shell-hook ()
      (progn
	(yas-minor-mode t)
	(if (tramp-tramp-file-p default-directory)
	    (progn
	      (message "Detected tramp shell!")
	      (setq-local company-backends (list 'company-yankpad 'company-yasnippet))
	      (setq-local bash-completion-enabled nil))
	  (setq-local company-backends (list (list 'company-capf 'company-yankpad 'company-yasnippet)))
	  (setq-local company-idle-delay nil)
	  )
	))
    (add-hook 'shell-mode-hook #'my-shell-hook)
    (bash-completion-setup)
    )
#+end_src

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package company-native-complete
    :ensure t
    :config
    (with-eval-after-load 'shell
      (native-complete-setup-bash))
    (defun my-shell-hook ()
      (yas-minor-mode t)
      (setq-local company-backends (list (list 'company-native-complete 'company-yankpad 'company-yasnippet))))
    (add-hook 'shell-mode-hook #'my-shell-hook)
    )
#+END_SRC

** Org mode

#+begin_src emacs-lisp :tangle yes
   (use-package org
   :ensure t)
#+end_src

*** Org-roam

Interlinking notes:

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package org-roam
      :hook 
      (after-init . org-roam-mode)
      :custom
      (org-roam-directory "~/.org/roam")
      :ensure t
      :bind (:map org-roam-mode-map
              (("C-c n l" . org-roam)
               ("C-c n f" . org-roam-find-file)
               ("C-c n b" . org-roam-switch-to-buffer)
               ("C-c n g" . org-roam-show-graph))
              :map org-mode-map
              (("C-c n i" . org-roam-insert))))
#+END_SRC

#+BEGIN_SRC  emacs-lisp :tangle yes
  (use-package company-org-roam
    :ensure t)    
#+END_SRC

*** Org-journal

I set up org-journal to work with org-roam. One org file per day, each file is in org-roam.

#+BEGIN_SRC emacs-lisp :tangle yes
   (use-package org-journal
     :ensure t
     :bind
     ("C-c n j" . org-journal-new-entry)
     :custom
     (org-journal-date-prefix "#+TITLE: ")
     (org-journal-time-prefix "* ")
     (org-journal-file-format "%Y-%m-%d.org")
     (org-journal-dir "~/.org/roam")
     (org-journal-date-format "%A, %d %B %Y")
     :config
     (defun org-journal-find-location ()
       ;; Open today's journal, but specify a non-nil prefix argument in order to
       ;; inhibit inserting the heading; org-capture will insert the heading.
       (org-journal-new-entry t)
       ;; Position point on the journal's top-level heading so that org-capture
       ;; will add the new entry as a child entry.
       (goto-char (point-min))))
#+END_SRC

*** Org protocol

Org protocol allows, among other things, capturing content from outside emacs.

**** Only once

 Create the following file:

 #+BEGIN_SRC text :file ~/.local/share/applications/org-protocol-handler.desktop
 [Desktop Entry]
   Version=1.0
   Type=Application
   Exec=/usr/local/bin/emacsclient %u
   Icon=/usr/share/icons/hicolor/scalable/apps/emacs.svg
   StartupNotify=true
   Terminal=false
   Categories=Utility;X-XFCE;X-Xfce-Toplevel;
   MimeType=x-scheme-handler/org-protocol
   Name=Org Protocol Handler
   Comment=Invoke emacsclient with org-protocol
 #+END_SRC

 Then add the following line to *~/.local/share/applications/mimeapps.list*:
 : x-scheme-handler/org-protocol=exo-org-protocol-handler.desktop

 Update the desktop database with this command

 #+BEGIN_SRC bash
   update-desktop-database  ~/.local/share/applications/
 #+END_SRC

**** Start org protocol

 #+BEGIN_SRC emacs-lisp :tangle yes
   (require 'org-protocol)
 #+END_SRC

*** Capturing

Org capture helps with taking specialized quick notes and capturing content outside of emacs.

**** org-capture

#+begin_src emacs-lisp :tangle yes
(use-package org-capture
  :bind
  ("C-c c" . 'org-capture)
  :custom
  (org-capture-templates '(
                           ;; I use j template to capture journal entries in org-journal
                           ("j" "Journal" entry (function org-journal-find-location)
                            "* %(format-time-string org-journal-time-format)%^{Title}\n%i%?")                           
                           )
                         )
  )
#+end_src
**** Templates
**** org-protocol-capture-html

 [[https://github.com/alphapapa/org-protocol-capture-html][org-protocol-capture-html]] builds on org-capture and uses panadoc to convert html to org-mode

 Clone it:

 #+BEGIN_SRC bash
   git clone git@github.com:alphapapa/org-protocol-capture-html.git ~/emacs_git/org-protocol-capture-html
 #+END_SRC

 It needs an org-capture template that I add here. The template adds the capture as an entry in the current org-journal file.

 #+BEGIN_SRC emacs-lisp
   (use-package org-protocol-capture-html
     :load-path "~/emacs_git/org-protocol-capture-html/"
     :after 
     org-protocol
     org-capture
     :config
     (add-to-list 'org-capture-templates '("w" "Web site" entry (function org-journal-find-location)
          "* %(format-time-string org-journal-time-format)%^{Title} :website:\n %a \n\n%U %?\n\n%:initial"))
     )
 #+END_SRC



 Set it up


 Deprecated

 #+begin_src emacs-lisp :tangle no
   (setq org-capture-templates
         '(setq org-capture-templates
                '(
                  ("w" "Web site" entry (function org-journal-find-location)
                   "* %(format-time-string org-journal-time-format)%^{Title} :website:\n %a \n\n%U %?\n\n%:initial")
                  ("j" "Journal" entry (function org-journal-find-location)
                   "* %(format-time-string org-journal-time-format)%^{Title}\n%i%?"))
                ;; ("n" "Note" entry (file+headline "~/.org/refile.org" "Notes")
                ;;  "* TODO %^{entry} :NOTE:\n    :PROPERTIES:\n    :FROM:%K\n    :END:\n%U\n%? %i\n%a\n" :clock-in t :clock-resume t)
                ;; ("t" "Todo" entry (file+headline "~/.org/refile.org" "Tasks")
                ;;  "* TODO %?\n%U\n%a\n" :clock-in t :clock-resume t)
                ;; ("j" "Journal" entry (file+olp+datetree "~/.org/journal.org")
                ;;  "* %?\nEntered on %U\n  %i\n  %a" :clock-in t :clock-resume t)
                ;; ("s" "Code Snippet" entry
                ;;  (file "~/.org/refile.org")
                ;;  ;; Prompt for tag and language
           ;;  "* %?\t%^g\n#+BEGIN_SRC %^{language}\n\n#+END_SRC"))
 o               ))
        
 #+end_src

**** Setup chrome

 Use: [[https://github.com/mikecrittenden/shortkeys/][mikecrittenden/shortkeys]]

***** Example

Setup a shortcut for ctrl+alt+c.

In the capture template body can be referred as %i and url+title as %a.

#+BEGIN_SRC js
   var captureLink =function(){
       var uri = 'org-protocol://capture?' +
           'template=n' +
           '&url=' + encodeURIComponent(window.location.href) +
           '&title=' + encodeURIComponent(document.title) +
           '&body=' + encodeURIComponent(window.getSelection().toString());
       window.location = uri
       return uri;
   };
   captureLink()
#+END_SRC

***** Full export 

In chrome I bind the following key shortcuts:

- ctrl+alt+c - plain capture (no org-protocol-capture-html)
- shift+alt+c - capture with org-protocol-capture-html
- ctrl+alt+shft+c - capture with org-protocol-capture-html using eww-readable (tries to select only test context from a site)

#+BEGIN_SRC js
[
  {
    "action": "javascript",
    "activeInInputs": true,
    "blacklist": "false",
    "code": "var captureLink =function(){\n  var uri = 'org-protocol://capture?' +\n        'template=n' +\n        '&url=' + encodeURIComponent(window.location.href) +\n        '&title=' + encodeURIComponent(document.title) + \n        '&body=' + encodeURIComponent(window.getSelection().toString());\n  window.location = uri\n  return uri;\n};\n\ncaptureLink()",
    "customName": "org-protocol-capture",
    "exported": true,
    "key": "ctrl+alt+c",
    "open": false,
    "sites": "*mail.google.com*",
    "sitesArray": [
      "*mail.google.com*"
    ]
  },
  {
    "action": "javascript",
    "activeInInputs": true,
    "blacklist": "false",
    "code": "var storeLink =function(){\n  var uri = 'org-protocol://store-link?url='+encodeURIComponent(location.href)\n  window.location = uri\n  return uri;\n}\n\nstoreLink()",
    "customName": "org-protocol-store-link",
    "exported": true,
    "key": "ctrl+alt+k",
    "open": false,
    "sites": "*mail.google.com*",
    "sitesArray": [
      "*mail.google.com*"
    ]
  },
  {
    "action": "javascript",
    "blacklist": false,
    "code": "var captureLink =function(){\n  var uri = 'org-protocol://capture-eww-readable?' +\n        'template=w' +\n        '&url=' + encodeURIComponent(window.location.href) +\n        '&title=' + encodeURIComponent(document.title || \"[untitled page]\") + \n        '&body=' + encodeURIComponent(window.getSelection().toString());\n  window.location = uri\n  return uri;\n};\n\ncaptureLink()",
    "customName": "org-protocol-capture-html-eww",
    "exported": true,
    "key": "ctrl+alt+shift+C",
    "open": false,
    "sites": "*mail.google.com*",
    "sitesArray": [
      "*mail.google.com*"
    ]
  },
  {
    "action": "javascript",
    "blacklist": false,
    "code": "javascript:location.href = 'org-protocol://capture-html?template=w&url=' + encodeURIComponent(location.href) + '&title=' + encodeURIComponent(document.title || \"[untitled page]\") + '&body=' + encodeURIComponent(function () {var html = \"\"; if (typeof document.getSelection != \"undefined\") {var sel = document.getSelection(); if (sel.rangeCount) {var container = document.createElement(\"div\"); for (var i = 0, len = sel.rangeCount; i < len; ++i) {container.appendChild(sel.getRangeAt(i).cloneContents());} html = container.innerHTML;}} else if (typeof document.selection != \"undefined\") {if (document.selection.type == \"Text\") {html = document.selection.createRange().htmlText;}} var relToAbs = function (href) {var a = document.createElement(\"a\"); a.href = href; var abs = a.protocol + \"//\" + a.host + a.pathname + a.search + a.hash; a.remove(); return abs;}; var elementTypes = [['a', 'href'], ['img', 'src']]; var div = document.createElement('div'); div.innerHTML = html; elementTypes.map(function(elementType) {var elements = div.getElementsByTagName(elementType[0]); for (var i = 0; i < elements.length; i++) {elements[i].setAttribute(elementType[1], relToAbs(elements[i].getAttribute(elementType[1])));}}); return div.innerHTML;}());",
    "customName": "org-protocol-capture-html",
    "exported": true,
    "key": "alt+shift+c",
    "open": false,
    "sites": "*mail.google.com*",
    "sitesArray": [
      "*mail.google.com*"
    ]
  }
]
#+END_SRC

*** Org download

Download and attach images to org files

#+BEGIN_SRC emacs-lisp 
(use-package org-download
  :config
  (setq org-download-screenshot-method "xfce4-screenshooter -r -o cat > %s"))
#+END_SRC

*** Org bullets

#+name: org-bullets
#+begin_src emacs-lisp :tangle yes
(use-package org-bullets
  :ensure t
  :config
  (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1))))
#+end_src

*** Completion

Company mode in org, disable pcomplete.

#+begin_src emacs-lisp :tangle yes
(defun my-org-mode-hook ()
  (add-hook 'completion-at-point-functions 'pcomplete-completions-at-point nil t)
  (setq-local company-backends (list (list 'company-capf 'company-yankpad 'company-org-roam)))
)
(add-hook 'org-mode-hook #'my-org-mode-hook)
#+end_src

*** Babel

**** Tangle on save

#+begin_src emacs-lisp :tangle yes
  (add-hook 'org-mode-hook (lambda () (add-hook 'after-save-hook #'org-babel-tangle nil t)))
#+end_src

**** Languages

***** Install ob-restclient

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package ob-restclient
    :ensure t)
#+END_SRC

***** Setup plantuml

Plantuml is a tool that's installed as a standalone application.

#+NAME: install-plant-uml :tangle no
#+BEGIN_SRC bash :dir /sudo:root@localhost:/root
  apt-get install plantuml
#+END_SRC

Org mode needs the path to the plantuml jar.

#+NAME: plantuml-jar-path
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq org-plantuml-jar-path "/usr/share/plantuml/plantuml.jar")
#+END_SRC

***** Setup languages

#+begin_src emacs-lisp :tangle yes
(org-babel-do-load-languages
 'org-babel-load-languages
 '((shell      . t)
   (js         . t)
   (ditaa      . t)
   (emacs-lisp . t)
   (perl       . t)
   (clojure    . t)
   (python     . t)

   (ruby       . t)
   (dot        . t)
   (css        . t)
   (sql        . t)
   (screen     . t)
   (plantuml   . t)
   (restclient   . t)
   (org        . t)
   (http       . t)
   (groovy     . t)
   (jq         . t)
   (elasticsearch . t)))
#+end_src


**** Settings

#+begin_src emacs-lisp :tangle yes
(setq org-confirm-babel-evaluate nil
      org-src-fontify-natively t
      org-src-tab-acts-natively t)
#+end_src

**** Async

#+begin_src emacs-lisp :tangle yes
(use-package ob-async
  :ensure t)
#+end_src

** K3D

Utility functions around [[https://github.com/rancher/k3d][k3d]]

#+BEGIN_SRC emacs-lisp
  (defun vibu/toggle-value-in-separated-string (separated separator value)
    (let* ((split (split-string (or separated "") separator t))
           (toggled (-contains? split value)))
      (if toggled
          (set 'split (-remove-item value split))
        (add-to-list 'split value))
      (and split (--reduce-r (format "%s%s%s" acc separator it) split))
   ))

  (defun k3d/list-clusters ()
    (-map (lambda (s) (string-trim (nth 1 (split-string s "|"))))
           (nbutlast (nthcdr 3
                             (split-string
                              (or (with-output-to-string
                                    (call-process-shell-command "k3d list" nil standard-output))
                                  (list)
                                  )
                              "\n" t)
                             )
                     )))

  (defun k3d/delete-cluster (name)
    (interactive (list (completing-read "Cluster Name: " (k3d/list-clusters))))
    (message (with-output-to-string
      (call-process-shell-command (format "k3d delete --name %s" name) nil standard-output)))
    )

  (defun k3d/start-cluster (name)
    (interactive (list (completing-read "Cluster Name: " (k3d/list-clusters))))
    (message (with-output-to-string
      (call-process-shell-command (format "k3d start --name %s" name) nil standard-output)))
    )

  (defun k3d/get-kubeconfig (name)
    (string-trim (with-output-to-string
                   (call-process-shell-command (format "k3d get-kubeconfig --name %s" name) nil standard-output)))
    )

  (defun k3d/toggle-cluster-config (name)
    (interactive (list (completing-read "Cluster Name: " (k3d/list-clusters))))
    (setenv "KUBECONFIG" (or
                          (vibu/toggle-value-in-separated-string (getenv "KUBECONFIG") ":" (k3d/get-kubeconfig name))
                          ""))
    )
#+END_SRC
**** ob-tmux

Enable executions of babel shell blocks in a tmux session inside a terminal
 
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package ob-tmux
  ;; Install package automatically (optional)
  :ensure t
  :custom
  (org-babel-default-header-args:tmux
   '((:results . "silent")	;
     (:session . "default")	; The default tmux session to send code to
     (:socket  . nil)))		; The default tmux socket to communicate with
  ;; The tmux sessions are prefixed with the following string.
  ;; You can customize this if you like.
  (org-babel-tmux-session-prefix "ob-")
  ;; The terminal that will be used.
  ;; You can also customize the options passed to the terminal.
  ;; The default terminal is "gnome-terminal" with options "--".
  (org-babel-tmux-terminal "terminator")
  (org-babel-tmux-terminal-opts '("-T" "ob-tmux" "--new-tab" "-x"))
  ;; Finally, if your tmux is not in your $PATH for whatever reason, you
  ;; may set the path to the tmux binary as follows:
  (org-babel-tmux-location "/usr/bin/tmux"))
#+END_SRC

* Incubating  
** Hydra

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package hydra
    :ensure t)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package pretty-hydra
    :ensure t)
#+END_SRC

*** Buffer switch hydra

From [[https://github.com/abo-abo/hydra/wiki/Switch-to-buffer][here]].

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun my/name-of-buffers (n)
    "Return the names of the first N buffers from `buffer-list'."
    (let ((bns
           (delq nil
                 (mapcar
                  (lambda (b)
                    (unless (string-match "^ " (setq b (buffer-name b)))
                      b))
                  (buffer-list)))))
      (subseq bns 1 (min (1+ n) (length bns)))))

  ;; Given ("a", "b", "c"), return "1. a, 2. b, 3. c".
  (defun my/number-names (list)
    "Enumerate and concatenate LIST."
    (let ((i 0))
      (mapconcat
       (lambda (x)
         (format "%d. %s" (cl-incf i) x))
       list
       ", ")))

  (defvar my/last-buffers nil)

  (defun vibu/shell-dir (buffer dir)
    (let ((default-directory (or dir (pwd))))
      (shell buffer))
    )

  (defun vibu/shell-tmp () 
    (interactive
     (vibu/shell-dir "*tmp-shell*" "/tmp")))
  

  (defun my/switch-to-buffer (arg)
    (interactive "p")
    (switch-to-buffer
     (nth (1- arg) my/last-buffers)))

  (defun my/switch-to-buffer-other-window (arg)
    (interactive "p")
    (switch-to-buffer-other-window
     (nth (1- arg) my/last-buffers)))

  (global-set-key
   "\C-o"
   (defhydra my/switch-to-buffer (:exit t
                                        :body-pre (setq my/last-buffers
                                                        (my/name-of-buffers 4)))
     "
  _o_ther buffers: %s(my/number-names my/last-buffers)
  tmp _s_hell 
  "
     ("o" my/switch-to-buffer "this window")
     ("O" my/switch-to-buffer-other-window "other window")
     ("s" vibu/shell-tmp)
     ("<escape>" nil)))
#+END_SRC

#+RESULTS:
: my/switch-to-buffer/body

*** Window hydra

#+BEGIN_SRC emacs-lisp :tangle yes
(require 'windmove)

(defun hydra-move-splitter-left (arg)
  "Move window splitter left."
  (interactive "p")
  (if (let ((windmove-wrap-around))
        (windmove-find-other-window 'right))
      (shrink-window-horizontally arg)
    (enlarge-window-horizontally arg)))

(defun hydra-move-splitter-right (arg)
  "Move window splitter right."
  (interactive "p")
  (if (let ((windmove-wrap-around))
        (windmove-find-other-window 'right))
      (enlarge-window-horizontally arg)
    (shrink-window-horizontally arg)))

(defun hydra-move-splitter-up (arg)
  "Move window splitter up."
  (interactive "p")
  (if (let ((windmove-wrap-around))
        (windmove-find-other-window 'up))
      (enlarge-window arg)
    (shrink-window arg)))

(defun hydra-move-splitter-down (arg)
  "Move window splitter down."
  (interactive "p")
  (if (let ((windmove-wrap-around))
        (windmove-find-other-window 'up))
      (shrink-window arg)
    (enlarge-window arg)))

 (defhydra hydra-window ()
   "
Movement^^        ^Split^         ^Switch^		^Resize^
----------------------------------------------------------------
_h_ ←       	_v_ertical    	_b_uffer		_q_ X←
_j_ ↓        	_x_ horizontal	_f_ind files	_w_ X↓
_k_ ↑        	_z_ undo      	_a_ce 1		_e_ X↑
_l_ →        	_Z_ reset      	_s_wap		_r_ X→
_F_ollow		_D_lt Other   	_S_ave		max_i_mize
_SPC_ cancel	_o_nly this   	_d_elete	
"
   ("h" windmove-left )
   ("j" windmove-down )
   ("k" windmove-up )
   ("l" windmove-right )
   ("q" hydra-move-splitter-left)
   ("w" hydra-move-splitter-down)
   ("e" hydra-move-splitter-up)
   ("r" hydra-move-splitter-right)
   ("b" ido-switch-buffer)
   ("f" ido-find-file)
   ("F" follow-mode)
   ("a" (lambda ()
          (interactive)
          (ace-window 1)
          (add-hook 'ace-window-end-once-hook
                    'hydra-window/body))
       )
   ("v" (lambda ()
          (interactive)
          (split-window-right)
          (windmove-right))
       )
   ("x" (lambda ()
          (interactive)
          (split-window-below)
          (windmove-down))
       )
   ("s" (lambda ()
          (interactive)
          (ace-window 4)
          (add-hook 'ace-window-end-once-hook
                    'hydra-window/body)))
   ("S" save-buffer)
   ("d" delete-window)
   ("D" (lambda ()
          (interactive)
          (ace-window 16)
          (add-hook 'ace-window-end-once-hook
                    'hydra-window/body))
       )
   ("o" delete-other-windows)
   ("i" ace-maximize-window)
   ("z" (progn
          (winner-undo)
          (setq this-command 'winner-undo))
   )
   ("Z" winner-redo)
   ("SPC" nil)
   )

 (global-set-key (kbd "<f10>") 'hydra-window/body)
#+END_SRC

#+RESULTS:
: hydra-window/body

*** Org mode hydra

#+BEGIN_SRC emacs-lisp :tangle yes
  (pretty-hydra-define org-global
    (:title "Org global" :hint none)
    ("Capture"
     (("c" org-capture "Capture")
      ("g" org-capture-goto-last-stored "Goto Last"))     
     "Roam"
     (("f" org-roam-find-file "Find")
      ("i" org-roam-insert "Insert")
      ("r" org-roam "Roam")
      )
     "Journal"
     (("n" org-journal-new-entry "New")
      ("t" org-journal-open-current-journal-file "Today"))
     "Timing"
     (("C" org-clock-in "Clock in")
      ("o" org-clock-out "Clock out")
      ("s" org-pomodoro "Start pomodoro"))
     )
    )

  (define-key global-map (kbd "<f12>") 'org-global/body)
#+END_SRC

#+RESULTS:
: org-global/body

*** My hydra

#+BEGIN_SRC emacs-lisp :tangle yes
  (defhydra k3d-hydra (:exit t :hint nil)
    "
  K3D^^
  --------
  _c_onfigure
  _s_tart
  _d_elete"
    ("c" k3d/toggle-cluster-config)
    ("s" k3d/start-cluster)
    ("d" k3d/delete-cluster)
    )
#+END_SRC    

#+RESULTS:
: k3d-hydra/body

#+BEGIN_SRC emacs-lisp :tangle yes
  ()
  
  (defhydra vibu-global (:exit t :hint nil)
    "
  VPN^^              	^Hydras		Web^^^^^^	Misc
  -------------------------------------------------------------
  start _v_pn        	_s_mart\ Parens	_c_hrome	_m_ake frame
  add _d_efault routes	_k_3d		_g_oogle	
  add _r_oute         	_b_uffers 	b_r_owse 	
"
    ("v" (funcall (yankpad-map-simulate "v")))
    ("d" (funcall (yankpad-map-simulate "d")))
    ("r" (funcall (yankpad-map-simulate "r")))
                               
    ("s" hydra-smartparens/body)
    ("k" k3d-hydra/body)
    ("b" my/switch-to-buffer/body)

    ("c" (start-process-shell-command "*chrome*" "*chrome*" "nohup google-chrome --remote-debugging-port=9222"))
    ("g" google-this)
    ("r" browse-url-at-point)

    ("m" vibu/make-frame-other-monitor)
    )
     

  (define-key global-map (kbd "<f9>") 'vibu-global/body)
#+END_SRC

#+RESULTS:
: vibu-global/body

*** Artist mode hydra

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package artist
    :ensure t
    :config
    (defhydra hydra-artist (:exit t :hint nil)
        "
    Shapes^^		Operations^^
    ----------------------------------------
    _r_ectangle		_C_ut-rectangle
    _p_oly-line		C_O_py-rectangle
                          _P_aste"		
    ("r" artist-select-op-rectangle)
    ("p" artist-select-op-poly-line)
    ("C" artist-select-op-cut-rectangle)
    ("O" artist-select-op-copy-rectangle)
    ("P" artist-select-op-paste)
    )
    (bind-key "C-c h" 'hydra-artist/body artist-mode-map)
    )
#+END_SRC

#+RESULTS:
: hydra-artist/body

** Discovery
*** Which key

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package which-key
    :ensure t
    :config
    (which-key-mode))
#+END_SRC

#+RESULTS:
: t

** GPG

GPG for keeping secrets.
[[https://www.masteringemacs.org/article/keeping-secrets-in-emacs-gnupg-auth-sources][Guide]]

*** External setup

***** Generate a key

#+begin_src bash
  gpg --gen-key
#+end_src

#+RESULTS:

*** Set up authsource files

#+begin_src emacs-lisp :tangle yes
(setq auth-sources
 '((:source "~/.emacs.d/secrets/.authinfo.gpg")))
#+end_src

#+RESULTS:
| :source | ~/.emacs.d/secrets/.authinfo.gpg |

** Org jira

I load org jira from a checked out git but if not available should load from package manager.

#+begin_src emacs-lisp :tangle yes
  (use-package org-jira
    :ensure t
    :custom
    (add-to-list 'org-agenda-files org-jira-working-dir)
    (jiralib-url "https://jira.axway.com/")
    (org-jira-custom-jqls
     '((:jql "project = APIGOV AND resolution = Unresolved AND reporter in (currentUser()) order by created DESC" :limit 100 :filename "opened-by-me"))))
#+end_src

*** Custom functions to create Axway tickets

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun vibu/org-jira-subtree-as-jira ()
    (let ((org-export-show-temporary-export-buffer nil))    
      (ox-jira-export-as-jira nil t nil t))
    (save-excursion
      (set-buffer "*Org JIRA Export*")
      (buffer-string)))
  
  (defun vibu/org-jira-get-subheading-as-jira (pom prefix)
    (org-with-point-at pom
      (if (org-goto-first-child)
          (let ((found (string-prefix-p prefix (org-entry-get (point) "ITEM"))))
               (while (and
                       (not found)
                       (org-goto-sibling))
                 (setq found (string-prefix-p prefix (org-entry-get (point) "ITEM"))))
               (when found
                    (vibu/org-jira-subtree-as-jira))
               )
        )
      )
    )

  (defun vibu/org-to-apigov (pom)
    `((fields
       (issuetype (name . ,(org-entry-get pom "issuetype")))
       (project (key . ,(org-entry-get pom "project")))
       (components ((name . ,(org-entry-get pom "components"))))
       (customfield_12332 (value . ,(org-entry-get pom "team")))
       (customfield_12431 (value . ,(org-entry-get pom "documentation")))
       (fixVersions ((name . ,(org-entry-get pom "fixVersions"))))
       (reporter (name . ,(org-entry-get pom "reporter")))
       (summary . ,(org-entry-get pom "ITEM"))
       (customfield_11731 . ,(org-entry-get pom "epic"))
       (customfield_10330 . ,(let ((points (org-entry-get pom "points")))
                                   (and points (string-to-number (org-entry-get pom "points")))))
       (description . ,(vibu/org-jira-get-subheading-as-jira pom "description:"))
       (customfield_13730 . ,(vibu/org-jira-get-subheading-as-jira pom "acceptance:"))
       ))
    )

  (defun vibu/org-find-up-tree (predicate)
    (save-excursion
      (while (and (not (funcall predicate)) (> (funcall outline-level) 1))
        (org-up-heading-safe)
        )
      
      (and (funcall predicate) (point))
      )
    )

  (defun vibu/org-jira-apigov-create-or-update ()
    (interactive)
    (let ((pom (vibu/org-find-up-tree (lambda () (org-entry-get (point) "issuetype")))))
      (and pom
           (let ((id (org-entry-get pom "ID")))
             (if id
                 (jiralib-update-issue id (cdr (car (vibu/org-to-apigov pom))))
               (let ((response (jiralib-call "createIssue" nil (vibu/org-to-apigov pom))))
                 (org-entry-put pom "ID" (cdr (assoc 'key response)))
                 )
               )
             )
           )
      )
    )
#+END_SRC


#+RESULTS:
: vibu/org-jira-apigov-create-or-update

** Forge

Forge integrates magit with gitlab and github.

#+begin_src emacs-lisp :tangle yes
    (use-package forge
      :ensure t
      :config
      (setq forge-alist (cons '("git.ecd.axway.int" "git.ecd.axway.int/api/v4" "git.ecd.axway.int" forge-gitlab-repository) forge-alist)))
#+end_src

#+RESULTS:
: t

*** Git secret

** Language server for java
:PROPERTIES:
:header-args: :tangle yes
:END:

*** Placeholder
#+BEGIN_SRC emacs-lisp :tangle yes
  (print "Nothing")
#+END_SRC

#+RESULTS:
: Nothing

*** Client install

**** treemacs

#+BEGIN_SRC emacs-lisp
  (use-package treemacs
    :ensure t)
#+END_SRC

#+RESULTS:

**** lsp-mode

 #+BEGIN_SRC emacs-lisp
   (use-package lsp-mode
     :ensure t
     :demand t
     :init (setq lsp-inhibit-message nil ; you may set this to t to hide messages from message area
		 lsp-eldoc-render-all nil
	         lsp-prefer-flymake nil
		 lsp-highlight-symbol-at-point nil)
     :config (add-hook `javascript-mode-hook (lambda () (lsp))))
 #+END_SRC

 #+RESULTS:
 : t

#+BEGIN_SRC emacs-lisp :tangle yes
(defhydra hydra-lsp (:exit t :hint nil)
  "
 Buffer^^               Server^^                   Symbol
-------------------------------------------------------------------------------------
 [_f_] format           [_M-r_] restart            [_d_] declaration  [_i_] implementation  [_o_] documentation
 [_m_] imenu            [_S_]   shutdown           [_D_] definition   [_t_] type            [_r_] rename
 [_x_] execute action   [_M-s_] describe session   [_R_] references   [_s_] signature"
  ("d" lsp-find-declaration)
  ("D" lsp-ui-peek-find-definitions)
  ("R" lsp-ui-peek-find-references)
  ("i" lsp-ui-peek-find-implementation)
  ("t" lsp-find-type-definition)
  ("s" lsp-signature-help)
  ("o" lsp-describe-thing-at-point)
  ("r" lsp-rename)

  ("f" lsp-format-buffer)
  ("m" lsp-ui-imenu)
  ("x" lsp-execute-code-action)

  ("M-s" lsp-describe-session)
  ("M-r" lsp-restart-workspace)
  ("S" lsp-shutdown-workspace))

  (define-key global-map (kbd "<f11>") 'hydra-lsp/body)
#+END_SRC

#+RESULTS:
: hydra-lsp/body

#+BEGIN_SRC emacs-lisp :tangle yes
(push "[/\\\\]vendor" lsp-file-watch-ignored)
#+END_SRC

#+RESULTS:
| [/\\]vendor | [/\\]\.git$ | [/\\]\.hg$ | [/\\]\.bzr$ | [/\\]_darcs$ | [/\\]\.svn$ | [/\\]_FOSSIL_$ | [/\\]\.idea$ | [/\\]\.ensime_cache$ | [/\\]\.eunit$ | [/\\]node_modules$ | [/\\]\.fslckout$ | [/\\]\.tox$ | [/\\]\.stack-work$ | [/\\]\.bloop$ | [/\\]\.metals$ | [/\\]target$ | [/\\]\.ccls-cache$ | [/\\]\.deps$ | [/\\]build-aux$ | [/\\]autom4te.cache$ | [/\\]\.reference$ |

#+begin_src emacs-lisp :tangle yes
(use-package lsp-treemacs
 :ensure t)
#+end_src

#+RESULTS:

**** company-lsp

 #+BEGIN_SRC emacs-lisp
 (use-package company-lsp
   :after  company
   :ensure t
   :config
   (add-hook 'java-mode-hook (lambda () (push 'company-lsp company-backends)))
   (setq company-lsp-enable-snippet t
         company-lsp-cache-candidates t))
 #+END_SRC

 #+RESULTS:
 : t

**** lsp-ui
 #+BEGIN_SRC emacs-lisp
 (use-package lsp-ui
   :ensure t
   :demand t
   :config
   (setq lsp-ui-sideline-enable t
         lsp-ui-sideline-show-symbol t
         lsp-ui-sideline-show-hover t
         lsp-ui-sideline-show-code-actions t
         lsp-ui-sideline-update-mode 'point))
 #+END_SRC

 #+RESULTS:
 : t

**** Lsp java

 #+BEGIN_SRC emacs-lisp
    (use-package lsp-java
      :ensure t
      :config
      ;; add lombok as agent for eclipse jdt
      (setq lsp-java-vmargs
	    (quote("-noverify" "-Xmx1G" "-XX:+UseG1GC" "-XX:+UseStringDeduplication" "-javaagent:/home/vibu/.java/lib/lombok/1.18.8/lombok.jar")))
      (setq lsp-java-maven-download-sources t)
      (add-hook 'java-mode-hook #'lsp))
 #+END_SRC

 #+RESULTS:
 : t

**** Dap mode

#+BEGIN_SRC emacs-lisp
  (use-package dap-mode
    :ensure t
    :after lsp-mode
    :config
    (dap-mode t)
    (dap-ui-mode t)
    (require 'dap-go)
    )
  (use-package dap-java
    :after (lsp-java))
#+END_SRC

#+RESULTS:

** Golang

Autocompletion

#+BEGIN_SRC emacs-lisp
(use-package company-go
  :ensure t)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package go-mode
    :ensure t
    :bind (:map go-mode-map
                ("C-c d" . 'dap-hydra))
    :config
    (setq lsp-gopls-hover-kind "FullDocumentation")
    (lsp-register-custom-settings
     '(("gopls.completeUnimported" t t)
       ("gopls.staticcheck" t t)))
    (add-hook `go-mode-hook (lambda ()
			      (push "/home/vibu/work/go/bin" exec-path) ;; make sure this is in path
			      ;; (setq-local company-backends (list (list 'company-go 'company-yasnippet)))

			      ;; (flycheck-mode)
			      ;; (local-set-key (kbd "M-.") 'godef-jump)
			      ;; (local-set-key (kbd "M-*") 'pop-tag-mark)
			      (local-set-key (kbd "M-p") 'compile)            ; Invoke compiler
			      (local-set-key (kbd "M-P") 'recompile)          ; Redo most recent compile cmd
                              ;; (setq-local lsp-gopls-codelens nil)
			      (lsp)
                              (add-hook 'before-save-hook #'lsp-format-buffer t t)
                              (add-hook 'before-save-hook #'lsp-organize-imports t t)			      ;;(go-guru-hl-identifier-mode)
                              (setq-local company-backends (list (list 'company-yankpad 'company-lsp)))
			      )
	      )
    )
#+END_SRC

#+RESULTS:
: dap-hydra

*** golangci-lint

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package flycheck-golangci-lint
  :ensure t
  :hook (go-mode . flycheck-golangci-lint-setup))
#+END_SRC

#+RESULTS:


*** Go mode hydra

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun vibu/go-test-toggle-arg (arg)
    (interactive "sArgument: ")
    (let* ((current-args
            (or (split-string (or go-test-args " ") " " t) (list)))
           (is-set (-contains? current-args arg)))
      (if is-set
          (set 'current-args (-remove-item arg current-args))
        (add-to-list 'current-args arg))
      (setq-local go-test-args
                  (or (and current-args (--reduce-r (format "%s %s" acc it) current-args))
                      nil))
      (not is-set))
    )

  (defun go-test-verbose ()
    (interactive)
    (setq-local go-test-verbose (not (or go-test-verbose nil))))

  (defun go-test-update ()
    (interactive)
    (setq-local go-test-update (vibu/go-test-toggle-arg "-update")))

  (defun go-test-no-cache ()
    (interactive)
    (setq-local go-test-no-cache (vibu/go-test-toggle-arg "-count=1")))
  
  (pretty-hydra-define hydra-go
    (:title "Go Mode")
    ("Test"
     (
      ("n" go-test-no-cache "no cache" :toggle t)
      ("u" go-test-update "update" :toggle t)
      ("v" go-test-verbose "verbose" :toggle t)
      ("l" go-test-current-test-cache "last")
      ("c" go-test-current-test "current")
      ("f"  go-test-current-file "file"))
     )
    )

  (bind-key "C-c h" 'hydra-go/body go-mode-map)
#+END_SRC

#+RESULTS:
: hydra-go/body

#+BEGIN_SRC emacs-lisp
  (use-package ob-go
    :ensure t)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC emacs-lisp
(use-package go-rename
  :ensure t)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC emacs-lisp
(use-package go-guru
  :ensure t)
#+END_SRC

#+RESULTS:

Gotest

#+BEGIN_SRC emacs-lisp
  (use-package gotest
    :ensure t)
#+END_SRC

#+RESULTS:

Gometalinter

#+BEGIN_SRC emacs-lisp
  (use-package flycheck-gometalinter
    :ensure t
    :config
    (setq flycheck-gometalinter-vendor t)
    (setq flycheck-gometalinter-fast t)
    (flycheck-gometalinter-setup))
#+END_SRC

#+RESULTS:
: t

Go snippets

#+BEGIN_SRC emacs-lisp
  (use-package go-snippets
    :ensure t)
#+END_SRC

#+RESULTS:

** Flycheck pos tip

:PROPERTIES:
:header-args: :tangle yes
:END:

#+BEGIN_SRC emacs-lisp
  (use-package flycheck-pos-tip
  :ensure t
  :config
  (add-hook 'flycheck-mode-hook (lambda ()
				  (flycheck-pos-tip-mode)
				  ))
  )
#+END_SRC

#+RESULTS:
: t

** Protobufs

#+BEGIN_SRC emacs-lisp
  (use-package protobuf-mode
    :ensure t
    )
#+END_SRC

#+RESULTS:

** Ejira

#+begin_src emacs-lisp :tangle yes
  (use-package language-detection
    :ensure t)
#+end_src

#+RESULTS:

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package ox-jira
  :ensure t)
#+END_SRC

#+RESULTS:

#+begin_src emacs-lisp :tangle no
(use-package ejira
  :load-path "~/emacs_git/ejira"
  :init
  (setq jiralib2-url             "https://jira.axway.com/secure"
        jiralib2-user-login-name "vbuciuc"
        ejira-projects           '("APIGOV")
        ejira-main-project       "APIGOV"
        ejira-scrum-project      "APIGOV"
        ejira-my-org-directory   "~/.org/jira/"
        ejira-done-states        '("Done")
        ejira-in-progress-states '("In Progress" "In Review" "Testing")
        ejira-high-priorities    '("High" "Highest")
        ejira-low-priorities     '("Low" "Lowest")
        ejira-sprint-field                     'customfield_11730
        ejira-epic-field                       'customfield_11731
        request--curl-cookie-jar "")
  :config
  (require 'ejira-agenda)
  (add-to-list 'org-agenda-files ejira-org-directory)
  (org-add-agenda-custom-command
   '("j" "My JIRA issues"
     ((ejira-jql "resolution = unresolved and assignee = currentUser()"
                 ((org-agenda-overriding-header "Assigned to me")))))))
#+end_src

#+RESULTS:
: t

** Jsonnet

#+BEGIN_SRC emacs-lisp :tangle yes
   (use-package jsonnet-mode
    :ensure t)
#+END_SRC

#+RESULTS:

** Org agenda

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package org-agenda
    :config
    (setq org-agenda-files (list "~/.org/knowledge.org" "~/.org/personal.org" "~/.org/work.org" "~/.org/workish.org" "~/.org/gtd.org" "~/.org/refile.org" "~/.org-jira/APIGOV.org" "~/.org/snippets.org"))
    :bind
    ("C-c C-a" . 'org-agenda))
#+END_SRC

#+RESULTS:
: org-agenda

*** Quick search through knowledge files

#+BEGIN_SRC emacs-lisp
  (add-to-list 'org-agenda-custom-commands
               '("ks" "Knowledge search" search ""
                 ((org-agenda-files (append `("~/.org/knowledge.org") (directory-files-recursively "~/.org/knowledge/" ".*\\.org"))))))
#+END_SRC

#+RESULTS:
| ks | Knowledge search     | search                                                                                                             |   | ((org-agenda-files (append (` (~/.org/knowledge.org)) (directory-files-recursively ~/.org/knowledge/ .*\.org)))) |
| j  | My JIRA issues       | ((ejira-jql resolution = unresolved and assignee = currentUser() ((org-agenda-overriding-header Assigned to me)))) |   |                                                                                                                  |
| n  | Agenda and all TODOs | ((agenda ) (alltodo ))                                                                                             |   |                                                                                                                  |

** Org refile

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq org-refile-targets '((org-agenda-files :maxlevel . 9)))
  (setq org-refile-use-outline-path 'file)
  (setq org-refile-allow-creating-parent-nodes 'confirm)
#+END_SRC

#+RESULTS:
: confirm

** Org pomodoro

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package org-pomodoro
    :config
    ; configure alert.el to send pomodoro notifications on dbus notifications
    (setq alert-user-configuration
          (cons '(((:category . "org-pomodoro")) notifications nil) alert-user-configuration))    
    :ensure t)
#+END_SRC

** Jenkins

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package jenkins
    :load-path "~/emacs_git/jenkins.el"
    :ensure t)
#+END_SRC

** Secrets

#+BEGIN_SRC emacs-lisp :tangle yes
  (if (file-exists-p "~/.emacs.d/secrets/secrets.el.gpg")
      (load-file "~/.emacs.d/secrets/secrets.el.gpg"))
#+END_SRC

#+RESULTS:
: t

** Eval in repl

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package eval-in-repl
    :ensure t
    :config
    (defun vibu/eir-shell-buffer-name ()
      (let ((org-src-info (org-babel-get-src-block-info)))
        (format "*eir-%s*"
                (or (and org-src-info
                         (alist-get :session (-third-item org-src-info)))
                    "default"))
        ))
    (defun vibu/eir-shell-dir ()
      (let ((org-src-info (org-babel-get-src-block-info)))
        (or (and org-src-info
                 (alist-get :dir (-third-item org-src-info)))
            nil)
        ))
    (defalias 'eir-send-to-shell
      (apply-partially 'eir-send-to-repl
                       ;; fun-change-to-repl
                       #'(lambda () (switch-to-buffer-other-window (vibu/eir-shell-buffer-name)))
                       ;; fun-execute
                       #'comint-send-input))
    (defun vibu/org-babel-expand-noweb-region (start end)
      (if (org-babel-get-src-block-info)
          (save-excursion
            (let* ((srcstart (progn
                               (org-backward-element)
                               (point)))
                   (srcend (progn
                             (org-end-of-line)
                             (point))))
              
              (polymode-with-current-base-buffer
               (lambda (buffer)
                 (let ((old-buf buffer))
                   (with-temp-buffer           
                     (erase-buffer)
                     (insert-buffer-substring old-buf srcstart srcend)
                     (insert "\n")
                     (insert-buffer-substring old-buf start end)
                     (insert "\n#+END_SRC")
                     (org-babel-expand-noweb-references nil old-buf)
                     )
                   )
                 )
               (current-buffer))
              )
            )
        (buffer-substring-no-properties start end)
        )  
      )
    (defun eir-eval-in-shell ()
      "eval-in-repl for shell."
      (interactive)
      ;; Define local variables
      (let* (;; Save current point
             (initial-point (point)))
        (eir-repl-start (regexp-quote (vibu/eir-shell-buffer-name))
                        (lambda () (interactive) (vibu/shell-dir (vibu/eir-shell-buffer-name) (vibu/eir-shell-dir)))
                        t)

        ;; Check if selection is present
        (if (and transient-mark-mode mark-active)
            ;; If selected, send region
            (eir-send-to-shell (vibu/org-babel-expand-noweb-region (point) (mark)))

          ;; If not selected, do all the following
          ;; Move to the beginning of line
          (beginning-of-line)
          ;; Set mark at current position
          (set-mark (point))
          ;; Go to the end of line
          (end-of-line)
          ;; Send region if not empty
          (if (not (equal (point) (mark)))
              (eir-send-to-shell (vibu/org-babel-expand-noweb-region (point) (mark)))
            ;; If empty, deselect region
            (setq mark-active nil))

          ;; Move to the next statement code if jumping
          (if eir-jump-after-eval
              (eir-next-code-line)
            ;; Go back to the initial position otherwise
            (goto-char initial-point)))))
    
    (defun eir-eval-in-shell2 ()
      "eval-in-repl for shell script (opposite behavior)

   This version has the opposite behavior to the eir-jump-after-eval
   configuration when invoked to evaluate a line."
      (interactive)
      (let ((eir-jump-after-eval (not eir-jump-after-eval)))
        (eir-eval-in-shell)))
    (add-hook 'sh-mode-hook
              '(lambda()
                 (local-set-key (kbd "C-<return>") 'eir-eval-in-shell)))
    (add-hook 'sh-mode-hook
              '(lambda()
                 (local-set-key (kbd "C-M-<return>") 'eir-eval-in-shell2))))
#+END_SRC

#+RESULTS:
: t

** Yankpad

[[https://github.com/Kungsgeten/yankpad][Yankpad]] is a snippet management tool over org-mode.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package yankpad
  :ensure t
  :init
  (require 'cl)
  :config
  (setq yankpad-file "~/.org/yankpad.org"))
#+END_SRC

#+RESULTS:
: t

** Elasticsearch
#+BEGIN_SRC emacs-lisp
  (use-package es-mode
    :ensure t
    )
#+END_SRC

** Javascript

#+BEGIN_SRC emacs-lisp
  (use-package js
    :bind (:map js-mode-map
                ("M-." . xref-find-definitions))
    :config
    (add-hook `js-mode-hook (lambda ()
                              (lsp)
                              )
              )
    )
#+END_SRC

#+RESULTS:
: t

** Typescript

#+BEGIN_SRC emacs-lisp
  (use-package typescript-mode
    :ensure t
    :config
    (add-hook `typescript-mode-hook (lambda () (lsp)))
    )
#+END_SRC

** Lua

Currently not loading lua mode since it has some compatibility issue with 27.0.91 that I have to look
into.

#+BEGIN_SRC emacs-lisp
  (use-package lua-mode
    :ensure t)
#+END_SRC
** Password store
*** Install pass

#+BEGIN_SRC bash :tangle no :dir /sudo:localhost:/tmp :session root
  apt install pass
#+END_SRC

*** Initialize pass

#+BEGIN_SRC bash :tangle no
  pass init vbuciuc@axway.com
  pass git init
#+END_SRC

*** Install pass mode


#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package pass
    :ensure t
    :config
    (auth-source-pass-enable))
#+END_SRC

[[https://github.com/DamienCassou/auth-password-store][Auth sources with pass]]

#+BEGIN_QUOTE
passwdstring
host: host.domain.com
user: user@domain.com
port: 993
#+END_QUOTE

** Smart Parens 

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package smartparens
  :ensure t
  :bind
  ("C-'" . hydra-smartparens/body)
  :config
  (require 'smartparens-config)
  (smartparens-global-mode)
  )
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes
  (defhydra hydra-smartparens (:hint nil)
  "
 Moving^^^^                       Slurp & Barf^^   Wrapping^^            Sexp juggling^^^^               Destructive
------------------------------------------------------------------------------------------------------------------------
 [_a_] beginning  [_n_] down      [_h_] bw slurp   [_R_]   rewrap        [_S_] split   [_t_] transpose   [_c_] change inner  [_w_] copy
 [_e_] end        [_N_] bw down   [_H_] bw barf    [_u_]   unwrap        [_s_] splice  [_A_] absorb      [_C_] change outer
 [_f_] forward    [_p_] up        [_l_] slurp      [_U_]   bw unwrap     [_r_] raise   [_E_] emit        [_k_] kill          [_g_] quit
 [_b_] backward   [_P_] bw up     [_L_] barf       [_(__{__[_] wrap (){}[]   [_j_] join    [_o_] convolute   [_K_] bw kill       [_q_] quit"
  ;; Moving
  ("a" sp-beginning-of-sexp)
  ("e" sp-end-of-sexp)
  ("f" sp-forward-sexp)
  ("b" sp-backward-sexp)
  ("n" sp-down-sexp)
  ("N" sp-backward-down-sexp)
  ("p" sp-up-sexp)
  ("P" sp-backward-up-sexp)

  ;; Slurping & barfing
  ("h" sp-backward-slurp-sexp)
  ("H" sp-backward-barf-sexp)
  ("l" sp-forward-slurp-sexp)
  ("L" sp-forward-barf-sexp)

  ;; Wrapping
  ("R" sp-rewrap-sexp)
  ("u" sp-unwrap-sexp)
  ("U" sp-backward-unwrap-sexp)
  ("(" sp-wrap-round)
  ("{" sp-wrap-curly)
  ("[" sp-wrap-square)

  ;; Sexp juggling
  ("S" sp-split-sexp)
  ("s" sp-splice-sexp)
  ("r" sp-raise-sexp)
  ("j" sp-join-sexp)
  ("t" sp-transpose-sexp)
  ("A" sp-absorb-sexp)
  ("E" sp-emit-sexp)
  ("o" sp-convolute-sexp)

  ;; Destructive editing
  ("c" sp-change-inner :exit t)
  ("C" sp-change-enclosing :exit t)
  ("k" sp-kill-sexp)
  ("K" sp-backward-kill-sexp)
  ("w" sp-copy-sexp)

  ("q" nil)
  ("g" nil))
#+END_SRC

#+RESULTS:
: hydra-smartparens/body
** Google this

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package google-this
    :ensure t
    )
#+END_SRC

** babel eval in repl

#+BEGIN_SRC emacs-lisp
  (use-package org-babel-eval-in-repl
    :ensure t
    :config
    (with-eval-after-load "ob"
      (require 'org-babel-eval-in-repl)
      (define-key org-mode-map (kbd "C-<return>") 'ober-eval-in-repl)
      (define-key org-mode-map (kbd "M-<return>") 'ober-eval-block-in-repl)))
#+END_SRC

** elfeed

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package elfeed-org
    :ensure t 
    :config
    (elfeed-org)
    (setq rmh-elfeed-org-files (list "~/.org/elfeed.org")))
#+END_SRC

** rego mode

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package rego-mode 
  :ensure t
  :custom
  (rego-repl-executable "opa")
  (rego-opa-command "opa"))
#+END_SRC

** chrome.el

Navigate chrome tabs from emacs.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package chrome
 :load-path "~/emacs_git/chrome.el/")
#+END_SRC

Chrome should be started in debug mode:

#+BEGIN_SRC bash :async
  google-chrome --remote-debugging-port=9222
#+END_SRC

** rg.el

rg.el is an interface to ripgrep

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package rg
    :ensure t
    :config
    (rg-enable-menu)
)
#+END_SRC

