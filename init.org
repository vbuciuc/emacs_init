#+Title: My org init file. [WIP]

* Loading this file

Add to emacs init file:

#+BEGIN_SRC emacs-lisp
(org-babel-load-file "~/emacs_init/init.org")
#+END_SRC

* Setup
:PROPERTIES:
:header-args: :tangle yes
:END:

** Use spaces by default

#+BEGIN_SRC emacs-lisp
  (setq-default indent-tabs-mode nil)
#+END_SRC

** Package management

*** Set up packages

Repositories for packages.

#+NAME: package_repos
#+BEGIN_SRC emacs-lisp
(require 'package)
(setq
 package-archives '(("gnu" . "https://elpa.gnu.org/packages/")
                    ("org" . "https://orgmode.org/elpa/")
                    ("melpa" . "https://melpa.org/packages/")
                    ("melpa-stable" . "https://stable.melpa.org/packages/"))
 package-archive-priorities '(("melpa" . 1)))
(package-initialize)
#+END_SRC

*** Use package

Use package is used to install all the other packages.

#+NAME: use_package
#+BEGIN_SRC emacs-lisp
(when (not package-archive-contents)
  (package-refresh-contents)
  (package-install 'use-package))

(require 'use-package)
#+END_SRC

** Font lock mode

Enables font lock mode (syntax highlighting in all buffers).

#+NAME: font_lock_mode
#+BEGIN_SRC emacs-lisp
(global-font-lock-mode 1)
#+END_SRC

** Default browser

o#+name: default_browser
#+begin_src emacs-lisp
(setq browse-url-browser-function `browse-url-chrome)
#+end_src

** Save backups in tmp dir

#+name backup_in_tmp
#+begin_src emacs-lisp :tangle yes
(setq backup-directory-alist
      `((".*" . ,temporary-file-directory)))
(setq auto-save-file-name-transforms
      `((".*" ,temporary-file-directory t)))
#+end_src

** Theme

#+begin_src emacs-lisp :tangle yes
  (load-theme 'tango-dark)
#+end_src

** Disable toolbar and menu

#+BEGIN_SRC emacs-lisp :tangle yes
  (menu-bar-mode -1)
  (tool-bar-mode -1)
#+END_SRC

** Start emacs server

#+BEGIN_SRC emacs-lisp
(server-start)
#+END_SRC

* Stable
:PROPERTIES:
:header-args: :tangle yes
:END:

Stable stuff shouldn't change too often.

** Company mode

Company mode is a completion framework.

*** Install company mode

#+name: install company mode
#+begin_src emacs-lisp :tangle yes
(use-package company
;; don't show compay-mode in modeline
  :diminish company-mode
  :init
  (setq
   company-dabbrev-ignore-case nil
   company-dabbrev-code-ignore-case nil
   company-dabbrev-downcase nil
   company-minimum-prefix-length 2)
  :config
  (global-company-mode t)
  (setq company-idle-delay 0)
  (global-set-key (kbd "s-SPC") 'company-complete))
#+end_src

*** Fuzzy matching in company mode: company-flx

#+name: company-flx
#+begin_src emacs-lisp :tangle yes
(use-package company-flx
  :ensure t
  :config
  (add-hook `global-company-mode-hook 'company-flx-mode)
  )
#+end_src

*** Documentation on completion candidates: company-quickhelp

#+name: compaby-quickhelp
#+begin_src emacs-lisp :tangle yes
(use-package company-quickhelp
  :ensure t
  :config
  (add-hook 'company-mode-hook (lambda () (company-quickhelp-mode 1))))
#+end_src

** Ido

Ido is a completion framework for minibuffer (ex: finding files, switching buffer)

*** Install flx-ido

Flx ido brings fuzzy matching to ido.

#+name: ido
#+begin_src emacs-lisp :tangle yes
(use-package flx-ido
  :ensure t
  :demand
  :init
  (setq
   ido-enable-flex-matching t
   ;; C-d to open directories
   ;; C-f to revert to find-file
   ido-show-dot-for-dired t
   ido-enable-dot-prefix t)
  :config
  (ido-mode 1)
  (ido-everywhere 1)
  (flx-ido-mode 1)
  :custom
  (flx-ido-threshold 20000 "Increase ido threshold")
  )
#+end_src

*** Ido vertical

Display ido results vertically

#+name: ido-vertical
#+begin_src emacs-lisp :tangle yes
(use-package ido-vertical-mode
  :ensure t
  :config
  (ido-vertical-mode 1))
#+end_src

*** Ido occur

Occur in minibuffer

#+name: ido-occur
#+begin_src emacs-lisp :tangle yes
(use-package ido-occur
  :ensure t
  :bind ("s-o" . ido-occur))
#+end_src

*** Ido completing read plus

#+name: ido-completing-read+
#+begin_src emacs-lisp :tangle yes
(use-package ido-completing-read+
  :ensure t
  :config
  (ido-ubiquitous-mode))
#+end_src

** Smex

#+name: smex
#+begin_src emacs-lisp :tangle yes
(use-package smex
  :ensure t
  :bind
  ("M-x" . 'smex)
  ("M-X" . 'smex-major-mode-commands)
  ("C-c C-c M-x" . 'execute-extended-command))
#+end_src

** Exec Path from Shell

Ensures that some env vars are copied from the parent shell.

#+NAME: exec_path
#+BEGIN_SRC emacs-lisp
(use-package exec-path-from-shell
 :ensure t
 :config
  (setq exec-path-from-shell-variables (quote ("PATH" "MANPATH" "GOPATH")))
  (exec-path-from-shell-initialize))
#+END_SRC

** Git
*** Git link

Git link generates links to git origin.

#+begin_src emacs-lisp :tangle yes
  (use-package git-link
    :ensure t
    :custom
    (git-link-remote-alist
     (quote
      (("github" git-link-github)
       ("bitbucket" git-link-bitbucket)
       ("gitorious" git-link-gitorious)
       ("gitlab" git-link-gitlab)
       ("git.ecd.axway.int" git-link-gitlab)))))
#+end_src

*** Global git gutter

#+begin_src emacs-lisp :tangle no
  (use-package git-gutter
    :ensure t
    :config
    (global-git-gutter-mode 1))
#+end_src

*** Magit

Magit is ___THE___ git interface

#+BEGIN_SRC emacs-lisp
(use-package magit
  :ensure t
  :config
  (global-set-key (kbd "C-x g") 'magit-status)
  (global-set-key (kbd "M-&") 'with-editor-async-shell-command))
#+END_SRC

** Projectile

#+NAME: projectile
#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :ensure t
    :init   (setq projectile-use-git-grep t)
    :config
    (projectile-mode t)
    (setq projectile-enable-caching t)
    (setq projectile-switch-project-action 'projectile-dired)
    (define-key projectile-mode-map (kbd "C-c p") 'projectile-command-map)
    :bind   (("s-f" . projectile-find-file)
	     ("s-F" . projectile-grep))
    :custom
    (projectile-project-root-files-bottom-up
     (quote
      ("pom.xml" ".git" ".hg" ".fslckout" "_FOSSIL_" ".bzr" "_darcs" ".projectile"))))
#+END_SRC

*** Projectile makes tramp slow

#+BEGIN_SRC emacs-lisp
(defadvice projectile-project-name (before projectile-project-name-on-tramp activate)
  (if (tramp-tramp-file-p default-directory)
      (setq-local projectile-project-name "TrampRemote")
    )
  )
#+END_SRC

*** Projectile ibuffer support

#+name: ibuffer-projectile
#+begin_src emacs-lisp :tangle yes
(use-package ibuffer-projectile
  :ensure t)
#+end_src

** Yasnippet

Snippets organized per mode.

#+BEGIN_SRC emacs-lisp
(use-package yasnippet
  :diminish yas-minor-mode
  :commands yas-minor-mode
  :config
  (yas-global-mode 1)
  (yas-reload-all)
  )
#+END_SRC

** Async

#+BEGIN_SRC emacs-lisp
(use-package async
  :ensure t
  :config
  (add-hook 'dired-mode-hook (lambda () (dired-async-mode 1))))
#+END_SRC

** Flycheck

#+BEGIN_SRC
(use-package flycheck
  :ensure t)
#+END_SRC

** Http

#+begin_src emacs-lisp :tangle yes
(use-package http
  :ensure t)
(use-package ob-http
  :ensure t)
#+end_src

** JQ

#+name: jq-mode
#+begin_src emacs-lisp :tangle yes
(use-package jq-mode
  :init
  (require 'ob-jq)
  :ensure t)
#+end_src

** Kubernetes

#+begin_src emacs-lisp :tangle yes
  (use-package kubernetes
    :ensure t
    :commands (kubernetes-overview)
    :custom
    (kubernetes-poll-frequency 3600)
    (kubernetes-redraw-frequency 3600)
    )

  (use-package kubernetes-tramp
    :ensure t)
#+end_src
** Yaml

Lint yaml with flycheck

#+name: flycheck-yamllint
#+begin_src emacs-lisp :tangle yes
(use-package flycheck-yamllint
  :ensure t
  :defer t
  :init
  (progn
    (eval-after-load 'flycheck
      '(add-hook 'flycheck-mode-hook 'flycheck-yamllint-setup))))
#+end_src

** Shell mode

#+name: bash-comppletion
#+begin_src emacs-lisp :tangle yes
  (use-package bash-completion
    :ensure t
    :config
    (defun my-shell-hook ()
      (progn
	(yas-minor-mode t)
	(if (tramp-tramp-file-p default-directory)
	    (progn
	      (message "Detected tramp shell!")
	      (setq-local company-backends (list 'company-yasnippet))
	      (setq-local bash-completion-enabled nil))
	  (setq-local company-backends (list (list 'company-capf 'company-yasnippet)))
	  (setq-local company-idle-delay nil)
	  )
	))
    (add-hook 'shell-mode-hook #'my-shell-hook)
    (bash-completion-setup)
    )
#+end_src

** Org mode

#+begin_src emacs-lisp :tangle yes
   (use-package org
   :ensure t)
#+end_src

*** Org bullets

#+name: org-bullets
#+begin_src emacs-lisp :tangle yes
(use-package org-bullets
  :ensure t
  :config
  (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1))))
#+end_src

*** Completion

Company mode in org, disable pcomplete.

#+begin_src emacs-lisp :tangle yes
(defun my-org-mode-hook ()
  (add-hook 'completion-at-point-functions 'pcomplete-completions-at-point nil t))
(add-hook 'org-mode-hook #'my-org-mode-hook)
(add-hook 'org-mode-hook (lambda () (setq-local company-backends (list 'company-capf 'company-yankpad))))
#+end_src

*** Babel

**** Tangle on save

#+begin_src emacs-lisp :tangle yes
  (add-hook 'org-mode-hook (lambda () (add-hook 'after-save-hook #'org-babel-tangle nil t)))
#+end_src

**** Languages

***** Install ob-restclient

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package ob-restclient
    :ensure t)
#+END_SRC

***** Setup plantuml

Plantuml is a tool that's installed as a standalone application.

#+NAME: install-plant-uml :tangle no
#+BEGIN_SRC bash :dir /sudo:root@localhost:/root
  apt-get install plantuml
#+END_SRC

Org mode needs the path to the plantuml jar.

#+NAME: plantuml-jar-path
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq org-plantuml-jar-path "/usr/share/plantuml/plantuml.jar")
#+END_SRC

***** Setup languages

#+begin_src emacs-lisp :tangle yes
(org-babel-do-load-languages
 'org-babel-load-languages
 '((shell      . t)
   (js         . t)
   (ditaa      . t)
   (emacs-lisp . t)
   (perl       . t)
   (clojure    . t)
   (python     . t)

   (ruby       . t)
   (dot        . t)
   (css        . t)
   (sql        . t)
   (screen     . t)
   (plantuml   . t)
   (restclient   . t)
   (org        . t)
   (http       . t)
   (groovy     . t)
   (jq         . t)
   (elasticsearch . t)))
#+end_src


**** Settings

#+begin_src emacs-lisp :tangle yes
(setq org-confirm-babel-evaluate nil
      org-src-fontify-natively t
      org-src-tab-acts-natively t)
#+end_src

**** Async

#+begin_src emacs-lisp :tangle yes
(use-package ob-async
  :ensure t)
#+end_src

*** Capture

**** Install

#+begin_src emacs-lisp :tangle yes
(use-package org-capture
  :bind
  ("C-c c" . 'org-capture))
#+end_src

**** Templates

#+begin_src emacs-lisp :tangle yes
  (setq org-capture-templates
        '(("n" "Note" entry (file+headline "~/.org/refile.org" "Notes")
           "* TODO %^{entry} :NOTE:\n    :PROPERTIES:\n    :FROM:%K\n    :END:\n%U\n%? %i\n%a\n" :clock-in t :clock-resume t)
          ("t" "Todo" entry (file+headline "~/.org/refile.org" "Tasks")
           "* TODO %?\n%U\n%a\n" :clock-in t :clock-resume t)
          ("j" "Journal" entry (file+olp+datetree "~/.org/journal.org")
           "* %?\nEntered on %U\n  %i\n  %a" :clock-in t :clock-resume t)
          ("s" "Code Snippet" entry
           (file "~/.org/refile.org")
           ;; Prompt for tag and language
           "* %?\t%^g\n#+BEGIN_SRC %^{language}\n\n#+END_SRC")))
#+end_src

* Incubating
** Hydra

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package hydra
    :ensure t)
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package pretty-hydra
    :ensure t)
#+END_SRC

*** Buffer switch hydra

From [[https://github.com/abo-abo/hydra/wiki/Switch-to-buffer][here]].

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun my/name-of-buffers (n)
    "Return the names of the first N buffers from `buffer-list'."
    (let ((bns
           (delq nil
                 (mapcar
                  (lambda (b)
                    (unless (string-match "^ " (setq b (buffer-name b)))
                      b))
                  (buffer-list)))))
      (subseq bns 1 (min (1+ n) (length bns)))))

  ;; Given ("a", "b", "c"), return "1. a, 2. b, 3. c".
  (defun my/number-names (list)
    "Enumerate and concatenate LIST."
    (let ((i 0))
      (mapconcat
       (lambda (x)
         (format "%d. %s" (cl-incf i) x))
       list
       ", ")))

  (defvar my/last-buffers nil)

  (defun my/switch-to-buffer (arg)
    (interactive "p")
    (switch-to-buffer
     (nth (1- arg) my/last-buffers)))

  (defun my/switch-to-buffer-other-window (arg)
    (interactive "p")
    (switch-to-buffer-other-window
     (nth (1- arg) my/last-buffers)))

  (global-set-key
   "\C-o"
   (defhydra my/switch-to-buffer (:exit t
                                        :body-pre (setq my/last-buffers
                                                        (my/name-of-buffers 4)))
     "
  _o_ther buffers: %s(my/number-names my/last-buffers)

  "
     ("o" my/switch-to-buffer "this window")
     ("O" my/switch-to-buffer-other-window "other window")
     ("<escape>" nil)))
#+END_SRC

#+RESULTS:
: my/switch-to-buffer/body


*** Window hydra

#+BEGIN_SRC emacs-lisp :tangle yes
 (defhydra hydra-window ()
   "
Movement^^        ^Split^         ^Switch^		^Resize^
----------------------------------------------------------------
_h_ ←       	_v_ertical    	_b_uffer		_q_ X←
_j_ ↓        	_x_ horizontal	_f_ind files	_w_ X↓
_k_ ↑        	_z_ undo      	_a_ce 1		_e_ X↑
_l_ →        	_Z_ reset      	_s_wap		_r_ X→
_F_ollow		_D_lt Other   	_S_ave		max_i_mize
_SPC_ cancel	_o_nly this   	_d_elete	
"
   ("h" windmove-left )
   ("j" windmove-down )
   ("k" windmove-up )
   ("l" windmove-right )
   ("q" hydra-move-splitter-left)
   ("w" hydra-move-splitter-down)
   ("e" hydra-move-splitter-up)
   ("r" hydra-move-splitter-right)
   ("b" ido-switch-buffer)
   ("f" ido-find-file)
   ("F" follow-mode)
   ("a" (lambda ()
          (interactive)
          (ace-window 1)
          (add-hook 'ace-window-end-once-hook
                    'hydra-window/body))
       )
   ("v" (lambda ()
          (interactive)
          (split-window-right)
          (windmove-right))
       )
   ("x" (lambda ()
          (interactive)
          (split-window-below)
          (windmove-down))
       )
   ("s" (lambda ()
          (interactive)
          (ace-window 4)
          (add-hook 'ace-window-end-once-hook
                    'hydra-window/body)))
   ("S" save-buffer)
   ("d" delete-window)
   ("D" (lambda ()
          (interactive)
          (ace-window 16)
          (add-hook 'ace-window-end-once-hook
                    'hydra-window/body))
       )
   ("o" delete-other-windows)
   ("i" ace-maximize-window)
   ("z" (progn
          (winner-undo)
          (setq this-command 'winner-undo))
   )
   ("Z" winner-redo)
   ("SPC" nil)
   )

 (global-set-key (kbd "<f10>") 'hydra-window/body)
#+END_SRC

#+RESULTS:
: hydra-window/body

*** Org mode hydra

#+BEGIN_SRC emacs-lisp :tangle yes
  (pretty-hydra-define org-global
    (:title "Org global" :hint none)
    ("Capture"
     (("c" org-capture "Capture")
      ("g" org-capture-goto-last-stored "Goto Last"))
     ))

  (define-key global-map (kbd "<f12>") 'org-global/body)
#+END_SRC

Lsp mode:

#+BEGIN_SRC emacs-lisp
(defhydra hydra-lsp (:exit t :hint nil)
  "
 Buffer^^               Server^^                   Symbol
-------------------------------------------------------------------------------------
 [_f_] format           [_M-r_] restart            [_d_] declaration  [_i_] implementation  [_o_] documentation
 [_m_] imenu            [_S_]   shutdown           [_D_] definition   [_t_] type            [_r_] rename
 [_x_] execute action   [_M-s_] describe session   [_R_] references   [_s_] signature"
  ("d" lsp-find-declaration)
  ("D" lsp-ui-peek-find-definitions)
  ("R" lsp-ui-peek-find-references)
  ("i" lsp-ui-peek-find-implementation)
  ("t" lsp-find-type-definition)
  ("s" lsp-signature-help)
  ("o" lsp-describe-thing-at-point)
  ("r" lsp-rename)

  ("f" lsp-format-buffer)
  ("m" lsp-ui-imenu)
  ("x" lsp-execute-code-action)

  ("M-s" lsp-describe-session)
  ("M-r" lsp-restart-workspace)
  ("S" lsp-shutdown-workspace))

  (define-key global-map (kbd "<f11>") 'hydra-lsp/body)
#+END_SRC

*** Artist mode hydra

#+BEGIN_SRC emacs-lisp :tangle yes
  (defhydra hydra-artist (:exit t :hint nil)
    "
  Shapes^^		Operations^^
  ----------------------------------------
  _r_ectangle		_C_ut-rectangle
  _p_oly-line		C_O_py-rectangle
  			_P_aste"		
  ("r" artist-select-op-rectangle)
  ("p" artist-select-op-poly-line)
  ("C" artist-select-op-cut-rectangle)
  ("O" artist-select-op-copy-rectangle)
  ("P" artist-select-op-paste)
  )
  ;; (bind-key "C-c h" 'hydra-artist/body artist-mode-map)
#+END_SRC

#+RESULTS:
: hydra-artist/body

** Discovery
*** Which key

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package which-key
    :ensure t
    :config
    (which-key-mode))
#+END_SRC
** GPG

GPG for keeping secrets.
[[https://www.masteringemacs.org/article/keeping-secrets-in-emacs-gnupg-auth-sources][Guide]]

*** External setup

***** Generate a key

#+begin_src bash
  gpg --gen-key
#+end_src

*** Set up authsource files

#+begin_src emacs-lisp :tangle yes
(setq auth-sources
 '((:source "~/.emacs.d/secrets/.authinfo.gpg")))
#+end_src

** Org jira

I load org jira from a checked out git but if not available should load from package manager.

#+begin_src emacs-lisp :tangle yes
  (use-package org-jira
    :ensure t
    :custom
    (add-to-list 'org-agenda-files org-jira-working-dir)
    (jiralib-url "https://techweb.axway.com/jira")
    (org-jira-custom-jqls
     '((:jql "project = APIGOV AND resolution = Unresolved AND reporter in (currentUser()) order by created DESC" :limit 100 :filename "opened-by-me"))))
#+end_src

** Forge

Forge integrates magit with gitlab and github.

#+begin_src emacs-lisp :tangle yes
    (use-package forge
      :ensure t
      :config
      (setq forge-alist (cons '("git.ecd.axway.int" "git.ecd.axway.int/api/v4" "git.ecd.axway.int" forge-gitlab-repository) forge-alist)))
#+end_src

*** Git secret

** Language server for java
:PROPERTIES:
:header-args: :tangle yes
:END:

*** Placeholder
#+BEGIN_SRC emacs-lisp :tangle yes
  (print "Nothing")
#+END_SRC

*** Client install

**** treemacs

#+BEGIN_SRC emacs-lisp
  (use-package treemacs
    :ensure t)
#+END_SRC

**** lsp-mode

 #+BEGIN_SRC emacs-lisp
   (use-package lsp-mode
     :ensure t
     :demand t
     :init (setq lsp-inhibit-message nil ; you may set this to t to hide messages from message area
		 lsp-eldoc-render-all nil
	         lsp-prefer-flymake nil
		 lsp-highlight-symbol-at-point nil)
     :config (add-hook `javascript-mode-hook (lambda () (lsp))))
 #+END_SRC

#+begin_src emacs-lisp :tangle yes
(use-package lsp-treemacs
 :ensure t)
#+end_src

**** company-lsp

 #+BEGIN_SRC emacs-lisp
 (use-package company-lsp
   :after  company
   :ensure t
   :config
   (add-hook 'java-mode-hook (lambda () (push 'company-lsp company-backends)))
   (setq company-lsp-enable-snippet t
         company-lsp-cache-candidates t))
 #+END_SRC

**** lsp-ui
 #+BEGIN_SRC emacs-lisp
 (use-package lsp-ui
   :ensure t
   :demand t
   :config
   (setq lsp-ui-sideline-enable t
         lsp-ui-sideline-show-symbol t
         lsp-ui-sideline-show-hover t
         lsp-ui-sideline-show-code-actions t
         lsp-ui-sideline-update-mode 'point))
 #+END_SRC

**** Lsp java

 #+BEGIN_SRC emacs-lisp
    (use-package lsp-java
      :ensure t
      :config
      ;; add lombok as agent for eclipse jdt
      (setq lsp-java-vmargs
	    (quote("-noverify" "-Xmx1G" "-XX:+UseG1GC" "-XX:+UseStringDeduplication" "-javaagent:/home/vibu/.java/lib/lombok/1.18.8/lombok.jar")))
      (setq lsp-java-maven-download-sources t)
      (add-hook 'java-mode-hook #'lsp))
 #+END_SRC

**** Dap mode

#+BEGIN_SRC emacs-lisp
  (use-package dap-mode
    :ensure t
    :after lsp-mode
    :config
    (dap-mode t)
    (dap-ui-mode t)
    ; don't start lsp in polymode
    )
  (use-package dap-java
    :after (lsp-java))
#+END_SRC

** Golang

Autocompletion

#+BEGIN_SRC emacs-lisp
(use-package company-go
  :ensure t)
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package go-mode
    :ensure t
    :config

    (add-hook `go-mode-hook (lambda ()
			      (push "/home/vibu/work/go/bin" exec-path) ;; make sure this is in path
			      ;; (setq-local company-backends (list (list 'company-go 'company-yasnippet)))
			      (add-hook `before-save-hook `gofmt-before-save) ;;; gofmt before save
			      ;; (flycheck-mode)
			      ;; (local-set-key (kbd "M-.") 'godef-jump)
			      ;; (local-set-key (kbd "M-*") 'pop-tag-mark)
			      (local-set-key (kbd "M-p") 'compile)            ; Invoke compiler
			      (local-set-key (kbd "M-P") 'recompile)          ; Redo most recent compile cmd
			      (lsp)
			      ;;(go-guru-hl-identifier-mode)
                              (setq-local company-backends (list (list 'company-yankpad 'company-lsp)))
			      )
	      )
    )
#+END_SRC

*** golangci-lint

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package flycheck-golangci-lint
  :ensure t
  :hook (go-mode . flycheck-golangci-lint-setup))
#+END_SRC

*** Go mode hydra

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun go-test-verbose ()
    (interactive)
    (setq-local go-test-verbose (not go-test-verbose)))

  (pretty-hydra-define hydra-go
    (:title "Go Mode")
    ("Test"
     (
      ("v" go-test-verbose "verbose" :toggle t)
      ("l" go-test-current-test-cache "last")
      ("c" go-test-current-test "current")
      ("f"  go-test-current-file "file"))
     ))

  (bind-key "C-c h" 'hydra-go/body go-mode-map)
#+END_SRC

#+RESULTS:
: hydra-go/body

#+BEGIN_SRC emacs-lisp
  (use-package ob-go
    :ensure t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package go-rename
  :ensure t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package go-guru
  :ensure t)
#+END_SRC

Gotest

#+BEGIN_SRC emacs-lisp
  (use-package gotest
    :ensure t)
#+END_SRC

Gometalinter

#+BEGIN_SRC emacs-lisp
  (use-package flycheck-gometalinter
    :ensure t
    :config
    (setq flycheck-gometalinter-vendor t)
    (setq flycheck-gometalinter-fast t)
    (flycheck-gometalinter-setup))
#+END_SRC

Go snippets

#+BEGIN_SRC emacs-lisp
  (use-package go-snippets
    :ensure t)
#+END_SRC

** Flycheck pos tip

:PROPERTIES:
:header-args: :tangle yes
:END:

#+BEGIN_SRC emacs-lisp
  (use-package flycheck-pos-tip
  :ensure t
  :config
  (add-hook 'flycheck-mode-hook (lambda ()
				  (flycheck-pos-tip-mode)
				  ))
  )
#+END_SRC
** Protobufs

#+BEGIN_SRC emacs-lisp
  (use-package protobuf-mode
    :ensure t
    )
#+END_SRC
** Ejira

#+begin_src emacs-lisp :tangle yes
  (use-package language-detection
    :ensure t)
#+end_src

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package ox-jira
  :ensure t)
#+END_SRC

#+begin_src emacs-lisp :tangle no
(use-package ejira
  :load-path "~/emacs_git/ejira"
  :init
  (setq jiralib2-url             "https://techweb.axway.com/jira"
        jiralib2-user-login-name "vbuciuc"
        ejira-projects           '("APIGOV")
        ejira-main-project       "APIGOV"
        ejira-scrum-project      "APIGOV"
        ejira-my-org-directory   "~/.org/jira/"
        ejira-done-states        '("Done")
        ejira-in-progress-states '("In Progress" "In Review" "Testing")
        ejira-high-priorities    '("High" "Highest")
        ejira-low-priorities     '("Low" "Lowest")
        ejira-sprint-field                     'customfield_11730
        ejira-epic-field                       'customfield_11731
        request--curl-cookie-jar "")
  :config
  (require 'ejira-agenda)
  (add-to-list 'org-agenda-files ejira-org-directory)
  (org-add-agenda-custom-command
   '("j" "My JIRA issues"
     ((ejira-jql "resolution = unresolved and assignee = currentUser()"
                 ((org-agenda-overriding-header "Assigned to me")))))))
#+end_src

** Jsonnet

#+BEGIN_SRC emacs-lisp :tangle yes
   (use-package jsonnet-mode
    :ensure t)
#+END_SRC
** Org agenda

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package org-agenda
    :config
    (setq org-agenda-files (list "~/.org/knowledge.org" "~/.org/personal.org" "~/.org/work.org" "~/.org/workish.org" "~/.org/gtd.org" "~/.org/refile.org" "~/.org-jira/APIGOV.org" "~/.org/snippets.org"))
    :bind
    ("C-c C-a" . 'org-agenda))
#+END_SRC

** Org refile

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq org-refile-targets '((org-agenda-files :maxlevel . 9)))
  (setq org-refile-use-outline-path 'file)
  (setq org-refile-allow-creating-parent-nodes 'confirm)
#+END_SRC

** Org protocol

*** Only once

Create the following file:

#+BEGIN_SRC text :file ~/.local/share/applications/org-protocol-handler.desktop
[Desktop Entry]
  Version=1.0
  Type=Application
  Exec=/usr/bin/emacsclient %u
  Icon=/usr/share/icons/hicolor/scalable/apps/emacs.svg
  StartupNotify=true
  Terminal=false
  Categories=Utility;X-XFCE;X-Xfce-Toplevel;
  MimeType=x-scheme-handler/org-protocol
  Name=Org Protocol Handler
  Comment=Invoke emacsclient with org-protocol
#+END_SRC

Then add the following line to *~/.local/share/applications/mimeapps.list*:
: x-scheme-handler/org-protocol=exo-org-protocol-handler.desktop

Update the desktop database with this command

#+BEGIN_SRC bash
  update-desktop-database  ~/.local/share/applications/
#+END_SRC

*** Setup chrome

Use: [[https://github.com/mikecrittenden/shortkeys/][mikecrittenden/shortkeys]]

Setup a shortcut for ctrl+alt+c.

In the capture template body can be referred as %i and url+title as %a.

#+BEGIN_SRC js
  var captureLink =function(){
      var uri = 'org-protocol://capture?' +
          'template=n' +
          '&url=' + encodeURIComponent(window.location.href) +
          '&title=' + encodeURIComponent(document.title) +
          '&body=' + encodeURIComponent(window.getSelection().toString());
      window.location = uri
      return uri;
  };
  captureLink()
#+END_SRC

*** Start org protocol

#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'org-protocol)
#+END_SRC

#+RESULTS:
: org-protocol

** Org pomodoro

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package org-pomodoro
    :ensure t)
#+END_SRC

** Jenkins

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package jenkins
    :load-path "~/emacs_git/jenkins.el"
    :ensure t)
#+END_SRC

** Secrets

#+BEGIN_SRC emacs-lisp :tangle yes
  (if (file-exists-p "~/.emacs.d/secrets/secrets.el.gpg")
      (load-file "~/.emacs.d/secrets/secrets.el.gpg"))
#+END_SRC

** Eval in repl

#+BEGIN_SRC emacs-lisp :tangle yes
   (use-package eval-in-repl
     :ensure t
     :config
     (defun eir-eval-in-shell2 ()
       "eval-in-repl for shell script (opposite behavior)

   This version has the opposite behavior to the eir-jump-after-eval
   configuration when invoked to evaluate a line."
       (interactive)
       (let ((eir-jump-after-eval (not eir-jump-after-eval)))
         (eir-eval-in-shell)))
     (add-hook 'sh-mode-hook
          '(lambda()
             (local-set-key (kbd "C-<return>") 'eir-eval-in-shell)))
     (add-hook 'sh-mode-hook
               '(lambda()
                  (local-set-key (kbd "C-M-<return>") 'eir-eval-in-shell2))))
#+END_SRC
** Yankpad

[[https://github.com/Kungsgeten/yankpad][Yankpad]] is a snippet management tool over org-mode.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package yankpad
  :ensure t
  :init
  (require 'cl)
  :config
  (setq yankpad-file "~/.org/yankpad.org"))
#+END_SRC
** Elasticsearch
#+BEGIN_SRC emacs-lisp
  (use-package es-mode
    :ensure t
    )
#+END_SRC

** Javascript

#+BEGIN_SRC emacs-lisp
  (use-package js
    :config
    (add-hook `js-mode-hook (lambda () (lsp)))
    )
#+END_SRC

** Typescript

#+BEGIN_SRC emacs-lisp
  (use-package typescript-mode
    :ensure t
    :config
    (add-hook `typescript-mode-hook (lambda () (lsp)))
    )
#+END_SRC

** Lua

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package lua-mode
    :ensure t)
#+END_SRC
** Password store
*** Install pass

#+BEGIN_SRC bash :tangle no :dir /sudo:localhost:/tmp :session root
  apt install pass
#+END_SRC

*** Initialize pass

#+BEGIN_SRC bash :tangle no
  pass init vbuciuc@axway.com
  pass git init
#+END_SRC

*** Install pass mode


#+BEGIN_SRC emacs-lisp
  (use-package pass
    :ensure t
    :config
    (auth-source-pass-enable))
#+END_SRC

[[https://github.com/DamienCassou/auth-password-store][Auth sources with pass]]

#+BEGIN_QUOTE
passwdstring
host: host.domain.com
user: user@domain.com
port: 993
#+END_QUOTE

** Smart Parens

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package smartparens
  :ensure t
  :bind
  ("C-'" . hydra-smartparens/body)
  :config
  (require 'smartparens-config)
  (add-hook 'go-mode-hook #'smartparens-mode)
  )
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes
  (defhydra hydra-smartparens (:hint nil)
  "
 Moving^^^^                       Slurp & Barf^^   Wrapping^^            Sexp juggling^^^^               Destructive
------------------------------------------------------------------------------------------------------------------------
 [_a_] beginning  [_n_] down      [_h_] bw slurp   [_R_]   rewrap        [_S_] split   [_t_] transpose   [_c_] change inner  [_w_] copy
 [_e_] end        [_N_] bw down   [_H_] bw barf    [_u_]   unwrap        [_s_] splice  [_A_] absorb      [_C_] change outer
 [_f_] forward    [_p_] up        [_l_] slurp      [_U_]   bw unwrap     [_r_] raise   [_E_] emit        [_k_] kill          [_g_] quit
 [_b_] backward   [_P_] bw up     [_L_] barf       [_(__{__[_] wrap (){}[]   [_j_] join    [_o_] convolute   [_K_] bw kill       [_q_] quit"
  ;; Moving
  ("a" sp-beginning-of-sexp)
  ("e" sp-end-of-sexp)
  ("f" sp-forward-sexp)
  ("b" sp-backward-sexp)
  ("n" sp-down-sexp)
  ("N" sp-backward-down-sexp)
  ("p" sp-up-sexp)
  ("P" sp-backward-up-sexp)

  ;; Slurping & barfing
  ("h" sp-backward-slurp-sexp)
  ("H" sp-backward-barf-sexp)
  ("l" sp-forward-slurp-sexp)
  ("L" sp-forward-barf-sexp)

  ;; Wrapping
  ("R" sp-rewrap-sexp)
  ("u" sp-unwrap-sexp)
  ("U" sp-backward-unwrap-sexp)
  ("(" sp-wrap-round)
  ("{" sp-wrap-curly)
  ("[" sp-wrap-square)

  ;; Sexp juggling
  ("S" sp-split-sexp)
  ("s" sp-splice-sexp)
  ("r" sp-raise-sexp)
  ("j" sp-join-sexp)
  ("t" sp-transpose-sexp)
  ("A" sp-absorb-sexp)
  ("E" sp-emit-sexp)
  ("o" sp-convolute-sexp)

  ;; Destructive editing
  ("c" sp-change-inner :exit t)
  ("C" sp-change-enclosing :exit t)
  ("k" sp-kill-sexp)
  ("K" sp-backward-kill-sexp)
  ("w" sp-copy-sexp)

  ("q" nil)
  ("g" nil))
#+END_SRC

#+RESULTS:
: hydra-smartparens/body
